// Generated by CoffeeScript 2.4.1
/*
source: https://curiosity-driven.org/prolog-interpreter
*/
var Conjunction, Database, Rule, Term, Variable, mergeBindings, zip;

mergeBindings = function(bindings1, bindings2) {
  var bindings, conflict;
  if ((!bindings1) || (!bindings2)) {
    return;
  }
  conflict = false;
  bindings = new Map();
  bindings1.forEach(function(value, variable) {
    return bindings.set(variable, value);
  });
  bindings2.forEach(function(value, variable) {
    var other, sub;
    other = bindings.get(variable);
    if (other) {
      sub = other.match(value);
      if (!sub) {
        return conflict = true;
      } else {
        return sub.forEach(function(value, variable) {
          return bindings.set(variable, value);
        });
      }
    } else {
      return bindings.set(variable, value);
    }
  });
  if (conflict) {
    return;
  }
  return bindings;
};

zip = function(arrays) {
  return arrays[0].map(function(el, idx) {
    return arrays.map(function(arr) {
      return arr[idx];
    });
  });
};

Variable = class Variable {
  constructor(name) {
    this.name = name;
  }

  toString() {
    return `Var(${this.name})`;
  }

  match(other, bindings = new Map()) {
    if (this !== other) {
      bindings.set(this, other);
    }
    return bindings;
  }

  substitute(bindings) {
    if (!bindings.has(this)) {
      return this;
    }
    
    // if value is a compound term then substitute
    // variables inside it too

    return bindings.get(this).substitute(bindings);
  }

};

Term = class Term {
  constructor(functor, args1 = []) {
    this.functor = functor;
    this.args = args1;
  }

  toString() {
    if (this.args.length === 0) {
      return this.functor;
    }
    return this.functor + ` ( ${this.args.join(', ')} )\n`;
  }

  * query(db) {
    return (yield* db.query(this));
  }

  match(other) {
    if (!(other instanceof Term)) {
      return other.match(this);
    }
    if ((this.functor !== other.functor) || (this.args.length !== other.args.length)) {
      return;
    }
    return zip([this.args, other.args]).map(function(args) {
      return args[0].match(args[1]);
    }).reduce(mergeBindings, new Map());
  }

  substitute(bindings) {
    return new Term(this.functor, this.args.map(function(arg) {
      return arg.substitute(bindings);
    }));
  }

};

Term.TRUE = new Term('true');

Term.TRUE.substitute = function() {
  return this;
};

Term.TRUE.query = function*() {
  return (yield this);
};

Conjunction = class Conjunction extends Term {
  constructor(args1) {
    super();
    this.args = args1;
  }

  toString() {
    return this.args.join(', ');
  }

  * query(db) {
    var self, solutions;
    self = this;
    solutions = function*(index, bindings) {
      var arg, item, ref, results, unified;
      arg = self.args[index];
      if (!arg) {
        return (yield self.substitute(bindings));
      } else {
        ref = db.query(arg.substitute(bindings));
        results = [];
        for (item of ref) {
          unified = mergeBindings(arg.match(item), bindings);
          if (unified) {
            results.push((yield* solutions(index + 1, unified)));
          } else {
            results.push(void 0);
          }
        }
        return results;
      }
    };
    return (yield* solutions(0, new Map()));
  }

  substitute(bindings) {
    return new Conjunction(this.args.map(function(arg) {
      return arg.substitute(bindings);
    }));
  }

};

Rule = class Rule {
  constructor(head1, body1) {
    this.head = head1;
    this.body = body1;
  }

  toString() {
    return `${this.head} :- ${this.body}`;
  }

};

Database = class Database {
  constructor(rules) {
    this.rules = rules;
  }

  toString() {
    return this.rules.join('.\n') + '.';
  }

  size() {
    return this.rules.length;
  }

  * query(goal) {
    var body, head, i, item, len, match, ref, results, rule;
    ref = this.rules;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      rule = ref[i];
      match = rule.head.match(goal);
      if (!match) {
        continue;
      }
      head = rule.head.substitute(match);
      body = rule.body.substitute(match);
      results.push((yield* (function*() {
        var ref1, results1;
        ref1 = body.query(this);
        results1 = [];
        for (item of ref1) {
          results1.push((yield head.substitute(body.match(item))));
        }
        return results1;
      }).call(this)));
    }
    return results;
  }

};

module.exports = {
  Term: Term,
  Rule: Rule,
  Variable: Variable,
  Conjunction: Conjunction,
  Database: Database
};

//# sourceMappingURL=interpreter.js.map

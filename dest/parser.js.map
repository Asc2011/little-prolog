{
  "version": 3,
  "file": "parser.js",
  "sourceRoot": "..",
  "sources": [
    "src/parser.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "###\nsource: https://curiosity-driven.org/prolog-interpreter\n###\n{ \n  Term\n  Rule\n  Variable\n  Conjunction\n  Database\n} = require './interpreter'\n\n\nlexer = ( text ) ->\n  tokenRegexp = /[A-Za-z_]+|:\\-|[()\\.,]/g\n  # match\n  while ( (match = tokenRegexp.exec text ) isnt null)\n    yield match[0]\n\n\nparser = ( tokens ) ->\n  done = no; current = no; scope = no\n  \n  next = -> { value: current, done } = tokens.next()\n\n\n  parseAtom = ->\n    name = current\n    unless /^[A-Za-z_]+$/.test name\n      msg = 'Bad atom name: ' + name\n      throw new SyntaxError msg\n    next()\n    name\n\n\n  parseTerm = ->\n    \n    if current is '('\n      next() # eat (\n      \n      args = []\n      until current is ')'\n        args.push parseTerm()\n        unless current in [ ',', ')' ]\n          msg = 'Expected , or ) in term but got ' + current\n          throw new SyntaxError msg\n  \n        next() if current is ',' # eat ,\n      next() # eat )\n      return new Conjunction args\n      \n    functor = parseAtom()\n    \n    if /^[A-Z_][A-Za-z_]*$/.test functor\n      \n      return new Variable('_') if functor is '_'\n      # variable X in the same scope should point\n      # to the same object\n      variable = scope[functor]\n      unless variable\n        variable = scope[functor] = new Variable functor\n\n      return variable\n      \n    if current isnt '(' then return new Term functor\n        \n    next() # eat (\n    \n    args = []\n    until current is ')'\n    \n      args.push parseTerm()\n      \n      unless current in [ ',', ')' ]\n        msg = 'Expected , or ) in term but got ' + current\n        throw new SyntaxError msg\n        \n      next() if current is ',' # eat ,\n    next() #  eat )\n    \n    return new Term functor, args\n\n\n  parseRule = ->\n    head = parseTerm()\n    \n    if current is '.'\n      next() # eat .\n      return new Rule head, Term.TRUE\n    \n    unless current is ':-'\n      msg = 'Expected :- in rule but got ' + current\n      throw new SyntaxError msg\n    \n    next() # eat :-\n    \n    args = []\n    until current is '.'\n      args.push parseTerm()\n      \n      unless current in [ ',', '.' ]\n        msg = 'Expected , or . in term but got ' + current\n        throw new SyntaxError msg\n        \n      next() if current is ',' # eat ,\n    next() # eat .\n    \n    body = if args.length == 1 then args[0] else new Conjunction args\n    \n    return new Rule head, body\n\n  next() # start the tokens iterator\n\n  return\n    parseRules: ( rules=[] ) ->\n      until done\n        # each rule gets its own scope for variables\n        scope = {}\n        rules.push parseRule()\n      rules\n    parseTerm: ( scope={} ) -> parseTerm()\n\n\nexample = ->\n  \n  p = \"\"\"\n    exists(A, list(A, _, _, _, _)).\n    exists(A, list(_, A, _, _, _)).\n    exists(A, list(_, _, A, _, _)).\n    exists(A, list(_, _, _, A, _)).\n    exists(A, list(_, _, _, _, A)).\n\n    rightOf(R, L, list(L, R, _, _, _)).\n    rightOf(R, L, list(_, L, R, _, _)).\n    rightOf(R, L, list(_, _, L, R, _)).\n    rightOf(R, L, list(_, _, _, L, R)).\n\n    middle(A, list(_, _, A, _, _)).\n\n    first(A, list(A, _, _, _, _)).\n\n    nextTo(A, B, list(B, A, _, _, _)).\n    nextTo(A, B, list(_, B, A, _, _)).\n    nextTo(A, B, list(_, _, B, A, _)).\n    nextTo(A, B, list(_, _, _, B, A)).\n    nextTo(A, B, list(A, B, _, _, _)).\n    nextTo(A, B, list(_, A, B, _, _)).\n    nextTo(A, B, list(_, _, A, B, _)).\n    nextTo(A, B, list(_, _, _, A, B)).\n\n    puzzle(Houses) :-\n      exists(house(red, english, _, _, _), Houses),\n      exists(house(_, spaniard, _, _, dog), Houses),\n      exists(house(green, _, coffee, _, _), Houses),\n      exists(house(_, ukrainian, tea, _, _), Houses),\n      rightOf(house(green, _, _, _, _), house(ivory, _, _, _, _), Houses),\n      exists(house(_, _, _, oldgold, snails), Houses),\n      exists(house(yellow, _, _, kools, _), Houses),\n      middle(house(_, _, milk, _, _), Houses),\n      first(house(_, norwegian, _, _, _), Houses),\n      nextTo(house(_, _, _, chesterfield, _), house(_, _, _, _, fox), Houses),\n      nextTo(house(_, _, _, kools, _),house(_, _, _, _, horse), Houses),\n      exists(house(_, _, orangejuice, luckystike, _), Houses),\n      exists(house(_, japanese, _, parliament, _), Houses),\n      nextTo(house(_, norwegian, _, _, _), house(blue, _, _, _, _), Houses),\n      exists(house(_, _, water, _, _), Houses),\n      exists(house(_, _, _, _, zebra), Houses).\n\n    solution(WaterDrinker, ZebraOwner) :-\n      puzzle(Houses),\n      exists(house(_, WaterDrinker, water, _, _), Houses),\n      exists(house(_, ZebraOwner, _, _, zebra), Houses).\n  \"\"\"\n  \n  rules     = parser( lexer p ).parseRules()\n  console.log \"\\ninsert #{rules.length}-rules into DB.\"\n  \n  db        = new Database rules\n  goalText  = 'solution( WaterDrinker, ZebraOwner )'\n  goal      = parser( lexer goalText ).parseTerm()\n  \n  for item from db.query goal\n    console.log \"\\n#{item}\"\n\n\n\nmodule.exports =\n  parser : parser\n  lexer  : lexer\n  solve  : example\n"
  ]
}